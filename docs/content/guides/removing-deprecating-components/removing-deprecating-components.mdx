import {
  DeprecateExample,
  DeprecateOutput,
  RemoveExample,
  RemoveOutput,
  RemoveRemoteExample,
  RemoveRemoteOutput,
} from './commands';
import { ExpandedDeprecate, ExpandedRemove } from './expanded-code';

# Removing and Deprecating Components

Refactoring code often causes components to become obsolete or irrelevant. This is where removing and deprecating components becomes useful and necessary.

## Deprecate components

When you deprecate a component you update it. This requires the component to be authored in your workspace or imported into it.

Run the following to deprecate a component:

<DeprecateExample />

<ExpandedDeprecate />

The output should display the following:

<DeprecateOutput />

The component has been modified. Snap it and export it to its remote scope.

The component's `deprecated` status can be seen in the UI (scope and workspace), as well as in the terminal, when running `bit show`, `bit status`, `bit install`, etc.

## Remove components from a workspace

:::caution Local components should be removed with caution

Learn more in the [Effects of deleting components from a workspace](#effects-of-deleting-components-from-a-workspace) section.
:::

<RemoveExample />

<ExpandedRemove />

<RemoveOutput />

### Effects of deleting components from a workspace

Other components in the workspace may depend on removed components. Meaning that removing these dependencies affects dependent components. Several cases may occur when deleting a local component:

- A _new_ component that depends on a _removed component_ is not affected. This is because Bit did not isolate the component.
- A _staged_ component that depends on a _removed component_ causes Bit to stop the remove command. To force it, we use the `--force` flag.
- An _exported component_ that depends on a local _removed component_ is not affected. This is because an exported component is isolated and immutable. So deleting a local dependency does not affect.

## Remove components from a remote scope

:::warning Removing components from their remote scope is highly inadvisable!
Deprecate components instead to avoid possible damage to dependent components and projects.

Learn more in the [Effects of deleting components](#effects-of-deleting-components) section.
:::

To remove a component from a remote scope, specify the full component ID.

<RemoveRemoteExample />

<ExpandedRemove />

The output should display the following:

<RemoveRemoteOutput />

### Effects of deleting components

To better understand how Bit handles deleted components, let's follow this example:

- The `left-pad` in the `utils` scope.
- A component `trim-right` depends on `left-pad` and is also in `utils` scope.
- A component `login` also depends on `left-pad` but is in another scope - `onboarding`.

This is what happens if we remove `left-pad`:

- Bit notifies that `trim-right` depends on `left-pad`. If we want to remove it, Bit asks to use the --force flag. This is because scopes don't cache their components.
- The `trim-right` component has a missing dependency `left-pad`. A refactor for `trim-right` is critical for it to work.
- `login` that also depends on `left-pad` is not affected by the removal of `left-pad`. This is because scopes keep a cache of external dependencies.
- It is still possible to source `login` to another consumer project, as the cache works for Bit.
- Installing `login` using npm fails because npm tries to install `left-pad` from its original scope.
